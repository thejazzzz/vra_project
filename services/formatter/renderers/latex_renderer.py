# services/formatter/renderers/latex_renderer.py
from services.formatter.schema import FormattedReport, FormattedSection
import re

class LatexRenderer:
    @staticmethod
    def render(report: FormattedReport) -> bytes:
        lines = []
        
        # Preamble
        lines.append(r"\documentclass{article}")
        lines.append(r"\usepackage[utf8]{inputenc}")
        lines.append(r"\usepackage{hyperref}")
        lines.append(r"\usepackage{geometry}")
        lines.append(r"\geometry{a4paper, margin=1in}")
        lines.append(r"\title{" + LatexRenderer._escape(report.title) + "}")
        
        # Escape authors and date
        safe_authors = [LatexRenderer._escape(a) for a in report.authors]
        lines.append(r"\author{" + ", ".join(safe_authors) + "}")
        lines.append(r"\date{" + LatexRenderer._escape(report.date) + "}")
        
        lines.append(r"\begin{document}")
        lines.append(r"\maketitle")
        
        if report.abstract:
            lines.append(r"\begin{abstract}")
            lines.append(LatexRenderer._escape(report.abstract))
            lines.append(r"\end{abstract}")
            
        # Sections
        for section in report.sections:
            lines.extend(LatexRenderer._render_section(section))
            
        # References (Simple manual list for now, BibTeX later)
        if report.references:
            lines.append(r"\begin{thebibliography}{99}")
            for ref in report.references:
                item = f"\\bibitem{{ref{ref.index}}} {LatexRenderer._escape(ref.text)}"
                if ref.url:
                    item += f" \\url{{{ref.url}}}"
                lines.append(item)
            lines.append(r"\end{thebibliography}")
            
        import json
        meta_str = json.dumps(report.meta, ensure_ascii=False) if isinstance(report.meta, dict) else str(report.meta)
        lines.append(r"\vspace{1cm}")
        lines.append(r"\hrule")
        lines.append(r"\small \textit{Generated by AI Researcher - Metrics: " + LatexRenderer._escape(meta_str) + r"}")
        
        lines.append(r"\end{document}")
        
        return "\n".join(lines).encode('utf-8')

    @staticmethod
    def _render_section(section: FormattedSection) -> list[str]:
        lines = []
        # Map levels to commands
        cmds = {1: "section", 2: "subsection", 3: "subsubsection"}
        cmd = cmds.get(section.level, "paragraph")
        
        lines.append(f"\\{cmd}{{{LatexRenderer._escape(section.title)}}}")
        # Numbering is automatic in LaTeX usually, so we ignore section.numbering unless explicit request.
        
        if section.content:
            text = section.content
            
            # Placeholder Strategy:
            # 1. Regex find all bold matches **...**
            # 2. Store them and replace with unique token
            # 3. Same for italics _..._
            # 4. Escape text
            # 5. Restore tokens with \textbf{<escaped_content>}
            
            bold_matches = []
            def bold_repl(m):
                bold_matches.append(m.group(1))
                return f"PHBOLD{len(bold_matches)-1}PH"
            
            text = re.sub(r'\*\*(.*?)\*\*', bold_repl, text)
            
            italic_matches = []
            def italic_repl(m):
                italic_matches.append(m.group(1))
                return f"PHITALIC{len(italic_matches)-1}PH"
            
            text = re.sub(r'_(.*?)_', italic_repl, text)
            
            # Now escape the safe text (which contains placeholders)
            text = LatexRenderer._escape(text)
            
            # Restore placeholders
            # We must escape the captured content too!
            for i, content in enumerate(bold_matches):
                safe_content = LatexRenderer._escape(content)
                text = text.replace(f"PHBOLD{i}PH", f"\\textbf{{{safe_content}}}")
                
            for i, content in enumerate(italic_matches):
                safe_content = LatexRenderer._escape(content)
                text = text.replace(f"PHITALIC{i}PH", f"\\textit{{{safe_content}}}")
            
            # List Detection Logic
            # We process line by line to detect lists
            # Note: text already has placeholders and is SAFE escaped (except the placeholders)
            
            processed_lines = []
            in_list = False
            
            for line in text.split('\n'):
                # Check for list item (assuming simple '- ' syntax)
                # We need to account that the dash might be escaped if it was processed? 
                # LatexRenderer._escape does NOT escape -, so we look for "- "
                stripped = line.strip()
                if stripped.startswith("- "):
                    if not in_list:
                        processed_lines.append(r"\begin{itemize}")
                        in_list = True
                    content = line.strip()[2:] # remove "- "
                    processed_lines.append(f"\\item {content}")
                else:
                    if in_list:
                        processed_lines.append(r"\end{itemize}")
                        in_list = False
                    processed_lines.append(line)
            
            if in_list:
                processed_lines.append(r"\end{itemize}")
                
            text = "\n".join(processed_lines)
            
            lines.append(text)
            
        for sub in section.subsections:
            lines.extend(LatexRenderer._render_section(sub))
            
        return lines

    @staticmethod
    def _escape(text: str) -> str:
        if not text: return ""
        chars = {
            "&": r"\&",
            "%": r"\%", 
            "$": r"\$",
            "#": r"\#",
            "_": r"\_",
            "{": r"\{",
            "}": r"\}",
            "~": r"\textasciitilde{}",
            "^": r"\textasciicircum{}",
            "\\": r"\textbackslash{}"
        }
        return "".join(chars.get(c, c) for c in text)
